{
  "name": "simple-markdown",
  "version": "0.0.2",
  "description": "Javascript markdown parsing, made simple",
  "main": "simple-markdown.js",
  "scripts": {
    "test": "make test"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/Khan/simple-markdown.git"
  },
  "keywords": [
    "math"
  ],
  "author": {
    "name": "Khan Academy"
  },
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/Khan/simple-markdown/issues"
  },
  "homepage": "https://github.com/Khan/simple-markdown",
  "gitHead": "62efb54d923cae20684a58e87ab159b21edda3b1",
  "readme": "simple-markdown\n===============\n\n[![Join the chat at https://gitter.im/Khan/simple-markdown](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/Khan/simple-markdown?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\n\nsimple-markdown is a markdown-like parser designed for simplicity\nand extensibility.\n\nPhilosophy\n----------\n\nMost markdown-like parsers aim for [speed][marked] or\n[edge case handling][CommonMark].\nsimple-markdown aims for extensibility and simplicity.\n\n[marked]: https://github.com/chjj/marked\n[CommonMark]: https://github.com/jgm/CommonMark\n\nWhat does this mean?\nMany websites using markdown-like languages have custom extensions,\nsuch as `@`mentions or issue number linking. Unfortunately, most\nmarkdown-like parsers don't allow extension without\nforking, and can be difficult to modify even when forked.\nsimple-markdown is designed to allow simple addition of\ncustom extensions without needing to be forked.\n\nAt Khan Academy, we use simple-markdown to format\nover half of our math exercises, because we need\n[markdown extensions][PerseusMarkdown] for math text and\ninteractive widgets.\n\n[PerseusMarkdown]: https://github.com/Khan/perseus/blob/master/src/perseus-markdown.jsx\n\nsimple-markdown is [MIT licensed][LICENSE].\n\n[LICENSE]: https://github.com/Khan/simple-markdown/blob/master/LICENSE\n\nGetting started\n---------------\n\nFirst, let's parse and output some generic markdown using\nsimple-markdown.\n\nIf you want to run these examples in\nnode, you should run `npm install` in the simple-markdown\nfolder or `npm install simple-markdown` in your project's\nfolder. Then you can acquire the `SimpleMarkdown` variable\nwith:\n\n```javascript\n    var SimpleMarkdown = require(\"simple-markdown\");\n```\n\nThen let's get a basic markdown parser and outputter.\n`SimpleMarkdown` provides default parsers/outputters for\ngeneric markdown:\n\n```javascript\n    var mdParser = SimpleMarkdown.defaultBlockParser;\n    var mdOutput = SimpleMarkdown.defaultOutput;\n```\n\n`mdParse` can give us a syntax tree:\n\n```javascript\n    var syntaxTree = mdParse(\"Here is a paragraph and an *em tag*.\");\n```\n\nLet's inspect our syntax tree:\n\n```javascript\n    // pretty-print this with 4-space indentation:\n    console.log(JSON.stringify(syntaxTree, null, 4));\n    => [\n        {\n            \"content\": [\n                {\n                    \"content\": \"Here is a paragraph and an \",\n                    \"type\": \"text\"\n                },\n                {\n                    \"content\": [\n                        {\n                            \"content\": \"em tag\",\n                            \"type\": \"text\"\n                        }\n                    ],\n                    \"type\": \"em\"\n                },\n                {\n                    \"content\": \".\",\n                    \"type\": \"text\"\n                }\n            ],\n            \"type\": \"paragraph\"\n        }\n    ]\n```\n\nThen to turn that into an array of React elements, we can\ncall `mdOutput`:\n\n```javascript\n    mdOutput(syntaxTree)\n    => [ { type: 'div',\n        key: null,\n        ref: null,\n        _owner: null,\n        _context: {},\n        _store: { validated: false, props: [Object] } } ]\n```\n\n\nAdding a simple extension\n-------------------------\n\nLet's add an underline extension! To do this, we'll need to create\na new rule and then make a new parser/outputter. The next section\nwill explain how all of these steps work in greater detail. (To\nfollow along with these examples, you'll also need\n[underscore][underscore].)\n\n[underscore]: http://underscorejs.org/\n\nFirst, we create a new rule. We'll look for double underscores\nsurrounding text.\n\nWe'll put underlines right\nbefore `em`s, so that `__` will be parsed before `_`\nfor emphasis/italics.\n\nA regex to capture this would look something\nlike `/^__([\\s\\S]+?)__(?!_)/`. This matches `__`, followed by\nany content until it finds another `__` not followed by a\nthird `_`.\n\n```javascript\n    var underlineRule = {\n        // Specify the order in which this rule is to be run\n        order: SimpleMarkdown.defaultRules.em.order - 0.5,\n        \n        // First we check whether a string matches\n        match: function(source) {\n            return /^__([\\s\\S]+?)__(?!_)/.exec(source);\n        },\n        \n        // Then parse this string into a syntax node\n        parse: function(capture, parse, state) {\n            return {\n                content: parse(capture[1], state)\n            };\n        },\n        \n        // Finally transform this syntax node into a\n        // React element\n        output: function(node, output) {\n            return React.DOM.u(null, output(node.content));\n        }\n    };\n```\n\nThen, we need to add this rule to the other rules:\n\n```javascript\n    var rules = _.extend({}, SimpleMarkdown.defaultRules, {\n        underline: underlineRule\n    });\n```\n\nFinally, we need to build our parser and outputter:\n\n```javascript\n    var rawBuiltParser = SimpleMarkdown.parserFor(rules);\n    var parse = function(source) {\n        var blockSource = source + \"\\n\\n\";\n        return rawBuiltParser(blockSource, {inline: false});\n    };\n    var output = SimpleMarkdown.outputFor(SimpleMarkdown.ruleOutput(rules));\n```\n\nNow we can use our custom `parse` and `output` functions to parse\nmarkdown with underlines!\n\n```javascript\n    var syntaxTree = parse(\"__hello underlines__\");\n    console.log(JSON.stringify(syntaxTree, null, 4));\n    => [\n        {\n            \"content\": [\n                {\n                    \"content\": [\n                        {\n                            \"content\": \"hello underlines\",\n                            \"type\": \"text\"\n                        }\n                    ],\n                    \"type\": \"underline\"\n                }\n            ],\n            \"type\": \"paragraph\"\n        }\n    ]\n    \n    output(syntaxTree)\n    => [ { type: 'div',\n        key: null,\n        ref: null,\n        _owner: null,\n        _context: {},\n        _store: { validated: false, props: [Object] } } ]\n```\n\n\nBasic parsing/output API\n------------------------\n\n#### `SimpleMarkdown.defaultBlockParse(source)`\n\nReturns a syntax tree of the result of parsing `source` with the\ndefault markdown rules. Assumes a block scope.\n\n#### `SimpleMarkdown.defaultInlineParse(source)`\n\nReturns a syntax tree of the result of parsing `source` with the\ndefault markdown rules, where `source` is assumed to be inline text.\nDoes not emit `<p>` elements. Useful for allowing inline markdown\nformatting in one-line fields where paragraphs, lists, etc. are\ndisallowed.\n\n#### `SimpleMarkdown.defaultImplicitParse(source)`\n\nParses `source` as block if it ends with `\\n\\n`, or inline if not.\n\n#### `SimpleMarkdown.defaultOutput(syntaxTree)`\n\nReturns React-renderable output for `syntaxTree`.\n\n*Note: raw html output will be coming soon*\n\n\nExtension Overview\n------------------\n\nElements in simple-markdown are generally created from rules.\nFor parsing, rules must specify `match` and `parse` methods.\nFor output, rules must specify an `output` method.\n\nHere is an example rule, a slightly modified version of what\nsimple-markdown uses for parsing **strong** (**bold**) text:\n\n```javascript\n    strong: {\n        match: function(source, state, lookbehind) {\n            return /^\\*\\*([\\s\\S]+?)\\*\\*(?!\\*)/.exec(source);\n        },\n        parse: function(capture, recurseParse, state) {\n            return {\n                content: recurseParse(capture[1], state)\n            };\n        },\n        output: function(node, recurseOutput) {\n            return React.DOM.strong(null, recurseOutput(node.content));\n        }\n    },\n```\n\nLet's look at those three methods in more detail.\n\n#### `match(source, state, lookbehind)`\n\nsimple-markdown calls your `match` function to determine whether the\nupcoming markdown source matches this rule or not.\n\n`source` is the upcoming source, beginning at the current position of\nparsing (source[0] is the next character).\n\n`state` is a mutable state object to allow for more complicated matching\nand parsing. The most common field on `state` is `inline`, which all of\nthe default rules set to true when we are in an inline scope, and false\nor undefined when we are in a block scope.\n\n`lookbehind` is the string previously captured at this parsing level, to\nallow for lookbehind. For example, lists check that lookbehind ends with\n`/^$|\\n *$/` to ensure that lists only match at the beginning of a new\nline.\n\nIf this rule matches, `match` should return an object, array, or\narray-like object, which we'll call `capture`, where `capture[0]`\nis the full matched source, and any other fields can be used in the\nrule's `parse` function. The return value from `Regexp.prototype.exec`\nfits this requirement, and the common use case is to return the result\nof `someRegex.exec(source)`.\n\nIf this rule does not match, `match` should return null.\n\nNOTE: If you are using regexes in your match function, your regex\nshould always begin with `^`. Regexes without leading `^`s can\ncause unexpected output or infinite loops.\n\n#### `parse(capture, recurseParse, state)`\n\n`parse` takes the output of `match` and transforms it into a syntax\ntree node object, which we'll call `node` here.\n\n`capture` is the non-null result returned from match.\n\n`recurseParse` is a function that can be called on sub-content and\nstate to recursively parse the sub-content. This returns an array.\n\n`state` is the mutable state threading object, which can be examined\nor modified, and should be passed through to any `recurseParse` calls.\n\nFor example, to parse inline sub-content, you can add `inline: true`\nto state, or `inline: false` to force block parsing (to leave the\nparsing scope alone, you can just pass `state` with no modifications).\nFor example:\n\n```javascript\n    var innerText = capture[1];\n    recurseParse(innerText, _.defaults({\n        inline: true\n    }, state));\n```\n    \n`parse` should return a `node` object, which can have custom fields\nthat will be passed to `output`, below. The one reserved field is\n`type`, which designates the type of the node, which will be used\nfor output. If no type is specified, simple-markdown will use the\ncurrent rule's type (the common case). If you have multiple ways\nto parse a single element, it can be useful to have multiple rules\nthat all return nodes of the same type.\n\n#### `output(node, recurseOutput)`\n\n`output` takes a syntax tree `node` and transforms it into\nReact-renderable output.\n\n`node` is the return value from `parse`, which has a type\nfield of the same type as the current rule, as well as any\ncustom fields created by `parse`.\n\n`recurseOutput` is a function to recursively output sub-tree\nnodes created by using `recurseParse` in `parse`.\n\nThe simple-markdown API contains several helper methods for\ncreating rules, as well as methods for creating parsers and\noutputters from rules.\n\nExtension API\n-------------\n\nsimple-markdown includes access to the default list of rules,\nas well as several functions to allow you to create parsers and\noutputters from modifications of those default rules, or even\nfrom a totally custom rule list.\n\nThese functions are separated so that you can customize\nintermediate steps in the parsing/output process, if necessary.\n\n#### `SimpleMarkdown.defaultRules`\n\nThe default rules, specified as an object, where the keys are\nthe rule types, and the values are objects containing `order`,\n`match`, `parse`, and `output` fields (these rules can be used\nfor both parsing and outputting).\n\n#### `SimpleMarkdown.parserFor(rules)`\n\nTakes a `rules` object and returns a parser for the rule types\nin the rules object, in order of increasing `order` fields,\nwhich must be present and a finite number for each rule.\nIn the case of order field ties, rules are ordered\nlexicographically by rule name. Each of the rules in the `rules`\nobject must contain a `match` and a `parse` function.\n\n#### `SimpleMarkdown.ruleOutput(rules)`\n\nTakes a `rules` object, containing an `output` function for\neach rule, and returns a function that can output a single\nsyntax tree node of any type that is in the `rules` object,\ngiven a node and a recursive output function. This is not\nthe final output function because it doesn't handle arrays\nof nodes or recursion (see `outputFor`).\n\n#### `SimpleMarkdown.outputFor(singleNodeOutputFunction)`\n\nTakes a function that can output any single syntax tree\nnode and returns a function that maps over syntax tree\narrays correctly.\n\nThe most common use case is to pass the output of\n`ruleOutput` as the parameter to `outputFor`:\n\n```javascript\n    var output = SimpleMarkdown.outputFor(SimpleMarkdown.ruleOutput(rules));\n```\n\n#### Putting it all together\n\nGiven a set of rules, one can create a single function\nthat takes an input content string and outputs a\nReact-renderable as follows. Note that since many rules\nexpect blocks to end in `\"\\n\\n\"`, we append that to source\ninput manually, in addition to specifying `inline: false`\n(`inline: false` is technically optional for all of the\ndefault rules, which assume `inline` is false if it is\nundefined).\n\n```javascript\n    var rules = SimpleMarkdown.defaultRules; // for example\n\n    var parser = SimpleMarkdown.parserFor(rules);\n    var output = SimpleMarkdown.outputFor(SimpleMarkdown.ruleOutput(rules));\n    \n    var blockParseAndOutput = function(source) {\n        // Many rules require content to end in \\n\\n to be interpreted\n        // as a block.\n        var blockSource = source + \"\\n\\n\";\n        var parseTree = parser(blockSource, {inline: false});\n        var outputResult = output(parseTree);\n        return outputResult;\n    };\n```\n\nExtension rules helper functions\n--------------------------------\n\n*Coming soon*\n\nLICENSE\n-------\nMIT. See the LICENSE file for text.\n",
  "readmeFilename": "README.md",
  "_id": "simple-markdown@0.0.2",
  "_shasum": "d00cc82b08aa81d4c63ef5c82721538917263eb4",
  "_from": "../../../../var/folders/d3/5wb8tw9n33n894hxw8rnxgqw0000gn/T/npm-70725-4bdc918a/git-cache-20e54d79e850/62efb54d923cae20684a58e87ab159b21edda3b1",
  "_resolved": "git://github.com/lwansbrough/simple-markdown.git#62efb54d923cae20684a58e87ab159b21edda3b1"
}
